{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/DEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDEX {\n\t/**\n\t * @notice Contract initializer.\n\t * @dev Contract deployer should call this function with the amount of LPTs and Ether they want for the initial liquidity pool.\n\t * @param tokens amount of LPTs to be transferred to DEX\n\t */\n\tfunction init(uint256 tokens) external payable returns (uint256);\n\n\t/**\n\t * @notice Sends Ether in exchange for LPTs. The amount of LPTs is determined by the price function.\n\t * @dev Make sure to exclude the amount of Ether sent while calculating the price.\n\t */\n\tfunction ethToToken() external payable returns (uint256 tokenOutput);\n\n\t/**\n\t * @notice Sends LPTs in exchange for Ether. The amount of Ether is determined by the price function.\n\t * @dev Make sure to exclude the amount of LPTs while calculating the price if they already transferred to DEX.\n\t */\n\tfunction tokenToEth(\n\t\tuint256 tokenInput\n\t) external returns (uint256 ethOutput);\n\n\t/**\n\t * @notice allows deposits of $BAL and $ETH to liquidity pool\n\t * NOTE: parameter is the msg.value sent with this function call. That amount is used to determine the amount of $BAL needed as well and taken from the depositor.\n\t * NOTE: user has to make sure to give DEX approval to spend their tokens on their behalf by calling approve function prior to this function call.\n\t * NOTE: Equal parts of both assets will be removed from the user's wallet with respect to the price outlined by the AMM.\n\t */\n\tfunction deposit() external payable returns (uint256 tokensDeposited);\n\n\t/**\n\t * @notice allows withdrawal of $BAL and $ETH from liquidity pool\n\t */\n\tfunction withdraw(\n\t\tuint256 amount\n\t) external returns (uint256 eth_amount, uint256 token_amount);\n}\n\nabstract contract _DEX is IDEX {\n\t/**\n\t * @dev Follow along with the [original tutorial](https://medium.com/@austin_48503/%EF%B8%8F-minimum-viable-exchange-d84f30bd0c90) Price section for an understanding of the DEX's pricing model and for a price function to add to your contract. No modifications are allowed.\n\t * @param xInput 교환하려는 입력 자산의 양\n\t * @param xReserves DEX 계약에 보유된 입력 자산의 예비금\n\t * @param yReserves DEX 계약에 보유된 출력 자산의 예비금\n\t * @return yOutput 교환할 때의 출력 자산의 양\n\t */\n\tfunction price(\n\t\tuint256 xInput,\n\t\tuint256 xReserves,\n\t\tuint256 yReserves\n\t) public pure returns (uint256 yOutput) {\n\t\tuint256 EXCHANGE_FEE_PER_1000 = 3; // 0.3% fee\n\t\tuint256 xInputAfterFee = xInput * (1000 - EXCHANGE_FEE_PER_1000);\n\t\tuint256 numerator = xInputAfterFee * yReserves;\n\t\tuint256 denominator = xReserves * 1000 + xInputAfterFee;\n\t\trequire(denominator > 0, \"division by zero\");\n\t\tyOutput = numerator / denominator;\n\t\treturn yOutput;\n\t}\n\n\t/**\n\t * @notice returns liquidity of a liquidity provider.\n\t */\n\tfunction getLiquidity(address lp) public view virtual returns (uint256);\n}\n\ncontract DEX is _DEX {\n\t/* ========== GLOBAL VARIABLES ========== */\n\n\tIERC20 public token;\n\tuint256 public totalLiquidity; // sum of all liquidity of LPs\n\n\taddress private THIS = address(this);\n\tmapping(address => uint256) private liquidity;\n\tbool private initialized;\n\n\t/* ========== EVENTS ========== */\n\n\t/**\n\t * @notice Emitted when ethToToken() swap transacted\n\t */\n\tevent EthToTokenSwap(\n\t\taddress swapper,\n\t\tuint256 tokenOutput,\n\t\tuint256 ethInput\n\t);\n\n\t/**\n\t * @notice Emitted when tokenToEth() swap transacted\n\t */\n\tevent TokenToEthSwap(\n\t\taddress swapper,\n\t\tuint256 tokensInput,\n\t\tuint256 ethOutput\n\t);\n\n\t/**\n\t * @notice Emitted when liquidity provided to DEX and mints LPTs.\n\t */\n\tevent LiquidityProvided(\n\t\taddress liquidityProvider,\n\t\tuint256 liquidityMinted,\n\t\tuint256 ethInput,\n\t\tuint256 tokensInput\n\t);\n\n\t/**\n\t * @notice Emitted when liquidity removed from DEX and decreases LPT count within DEX.\n\t */\n\tevent LiquidityRemoved(\n\t\taddress liquidityRemover,\n\t\tuint256 liquidityWithdrawn,\n\t\tuint256 tokensOutput,\n\t\tuint256 ethOutput\n\t);\n\n\t/* ========== MODIFIERS ========== */\n\n\tmodifier positiveMessageValue() {\n\t\trequire(msg.value > 0, \"msg.value must be positive\");\n\t\t_;\n\t}\n\n\tmodifier positiveInteger(uint256 param) {\n\t\trequire(param > 0, \"param must be positive\");\n\t\t_;\n\t}\n\n\tmodifier requireLiquidity(address owner, uint256 amount) {\n\t\trequire(\n\t\t\tliquidity[owner] >= amount,\n\t\t\t\"require liquidity when withdrawing\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier ratioEqualExcludeEtherReceived(uint256 eth_sent) {\n\t\tuint256 beforeRatio = getRatio(eth_sent);\n\t\t_;\n\t\trequire(beforeRatio == getRatio(0), \"Ratio changed\");\n\t}\n\n\t/* ========== CONSTRUCTOR ========== */\n\n\tconstructor(address token_addr) {\n\t\ttoken = IERC20(token_addr);\n\t}\n\n\t/* ========== EXTERNAL FUNCTIONS ========== */\n\n\t// deployer initializes the DEX with Ether and tokens\n\t// return total amount of Ether in the liquidity pool\n\tfunction init(\n\t\tuint256 tokens\n\t)\n\t\texternal\n\t\tpayable\n\t\toverride\n\t\tpositiveMessageValue\n\t\tpositiveInteger(tokens)\n\t\treturns (uint256)\n\t{\n\t\trequire(!initialized, \"DEX already initialized\");\n\t\treceiveTokenFromCaller(tokens);\n\t\treturn liquidity[msg.sender] = totalLiquidity = THIS.balance;\n\t}\n\n\t// send Ether to DEX in exchange for tokens\n\t// return the amount of tokens received\n\tfunction ethToToken()\n\t\texternal\n\t\tpayable\n\t\toverride\n\t\tpositiveMessageValue\n\t\treturns (uint256 tokenOutput)\n\t{\n\t\ttokenOutput = exchange_ether_to_token(msg.value);\n\t\tsendTokenToCaller(tokenOutput);\n\t\temit EthToTokenSwap(msg.sender, tokenOutput, msg.value);\n\t\treturn tokenOutput;\n\t}\n\n\t// send tokens to DEX in exchange for Ether\n\t// return the amount of Ether received\n\tfunction tokenToEth(\n\t\tuint256 tokenInput\n\t)\n\t\texternal\n\t\toverride\n\t\tpositiveInteger(tokenInput)\n\t\treturns (uint256 ethOutput)\n\t{\n\t\treceiveTokenFromCaller(tokenInput);\n\t\tethOutput = exchange_token_to_ether(tokenInput);\n\t\tpayable(msg.sender).transfer(ethOutput);\n\t\temit TokenToEthSwap(msg.sender, tokenInput, ethOutput);\n\t\treturn ethOutput;\n\t}\n\n\t// deposits both Ether and tokens\n\t// the ratio of Ether to tokens will be maintained\n\t// return the amount of tokens deposited\n\tfunction deposit()\n\t\texternal\n\t\tpayable\n\t\toverride\n\t\tpositiveMessageValue\n\t\tratioEqualExcludeEtherReceived(msg.value)\n\t\treturns (uint256 tokensDeposited)\n\t{\n\t\tuint256 eth_amount = msg.value;\n\t\tuint256 eth_reserve = THIS.balance - eth_amount;\n\t\taddLiquidity(\n\t\t\tmsg.sender,\n\t\t\ttokensDeposited = (eth_amount * totalLiquidity) / eth_reserve\n\t\t);\n\n\t\tuint256 token_reserve = token.balanceOf(THIS);\n\t\tuint256 token_amount = (eth_amount * token_reserve) / eth_reserve;\n\t\treceiveTokenFromCaller(token_amount);\n\n\t\temit LiquidityProvided(\n\t\t\tmsg.sender,\n\t\t\ttokensDeposited,\n\t\t\teth_amount,\n\t\t\ttoken_amount\n\t\t);\n\t\treturn tokensDeposited;\n\t}\n\n\t// allows withdrawal of $BAL and $ETH from liquidity pool\n\t// return the amount of Ether and tokens withdrawn\n\tfunction withdraw(\n\t\tuint256 amount\n\t)\n\t\texternal\n\t\toverride\n\t\tpositiveInteger(amount)\n\t\trequireLiquidity(msg.sender, amount)\n\t\tratioEqualExcludeEtherReceived(0)\n\t\treturns (uint256 eth_amount, uint256 token_amount)\n\t{\n\t\tuint256 eth_reserve = THIS.balance;\n\t\teth_amount = (amount * eth_reserve) / totalLiquidity;\n\n\t\tuint256 token_reserve = token.balanceOf(THIS);\n\t\ttoken_amount = (amount * token_reserve) / totalLiquidity;\n\n\t\tpayable(msg.sender).transfer(eth_amount);\n\t\tsubLiquidity(msg.sender, eth_amount);\n\t\tsendTokenToCaller(token_amount);\n\n\t\temit LiquidityRemoved(msg.sender, eth_amount, token_amount, eth_amount);\n\t\treturn (eth_amount, token_amount);\n\t}\n\n\t/* ========== PRIVATE FUNCTIONS ========== */\n\n\t// Note: DEX contract become a msg.sender when calling functions of a token contract.\n\t// To reduce confusion, all interactions with the token which modify its status are handled through private functions.\n\n\tfunction receiveTokenFromCaller(\n\t\tuint256 amount\n\t) private positiveInteger(amount) {\n\t\trequire(\n\t\t\ttoken.allowance(msg.sender, THIS) >= amount,\n\t\t\t\"require allowance when receiving tokens\"\n\t\t);\n\t\ttoken.transferFrom(msg.sender, THIS, amount);\n\t}\n\n\tfunction sendTokenToCaller(uint256 amount) private positiveInteger(amount) {\n\t\ttoken.transfer(msg.sender, amount);\n\t}\n\n\tfunction addLiquidity(address lp, uint256 amount) private {\n\t\tliquidity[lp] += amount;\n\t\ttotalLiquidity += amount;\n\t}\n\n\tfunction subLiquidity(\n\t\taddress lp,\n\t\tuint256 amount\n\t) private requireLiquidity(lp, amount) {\n\t\tliquidity[lp] -= amount;\n\t\ttotalLiquidity -= amount;\n\t}\n\n\t/* ========== PRIVATE VIEW FUNCTIONS ========== */\n\n\t/**\n\t * @dev assume that ether already transferred to DEX. Which means an Ether balance of DEX contract is increased by etherInput. To calculate correct price, we need to subtract etherInput from the Ether balance of DEX contract.\n\t */\n\tfunction exchange_ether_to_token(\n\t\tuint256 etherInput\n\t) private view returns (uint256 tokenOutput) {\n\t\treturn\n\t\t\tprice(etherInput, THIS.balance - etherInput, token.balanceOf(THIS));\n\t}\n\n\t/**\n\t * @dev assume that token already transferred to DEX. Which means a token balance of DEX contract is increased by tokenInput. To calculate correct price, we need to subtract tokenInput from the token balance of DEX contract.\n\t */\n\tfunction exchange_token_to_ether(\n\t\tuint256 tokenInput\n\t) private view returns (uint256 etherOutput) {\n\t\treturn\n\t\t\tprice(tokenInput, token.balanceOf(THIS) - tokenInput, THIS.balance);\n\t}\n\n\tfunction getLiquidity(address lp) public view override returns (uint256) {\n\t\treturn liquidity[lp];\n\t}\n\n\tfunction getRatio(uint256 eth_sent) private view returns (uint256 ratio) {\n\t\tuint256 eth_reserve = THIS.balance - eth_sent;\n\t\tuint256 token_reserve = token.balanceOf(THIS);\n\t\tratio = eth_reserve / token_reserve;\n\t\treturn ratio;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}